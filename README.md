# API-DEMO
A quick demonstartion of an API using spring boot and swagger

## Compile

This is intended to be compiled using java 17 at a minimum

```
$ mvn clean install
```

## Run

In the target directory

```
$ java -jar api-demo*.jar
```
## Configuration

Configuration is in the internal __application.properties__ file

server.port is set to __8081__ in the configuration file using:
```
server.port: 8081
```

Should you wish to change the configuration of an already compiled up jar file, an
__application.properties__ file in the directory from which you run the jar file can
be used to overide any property file entries.

i.e. if you create a file __application.properties__ containing:
```
server.port: 8087
```
and run the jar from the directory it is in then the server will listen on port __8087__
 
## Swagger

Swagger is an automatically generated part of the application that descibes API facilities
and allows testing of them; it is available at
```
localhost:8081/swagger-ui/
```

Swagger generates a GUI that displays:

* The available API end points.
* An indication of what paramaters are required and how they should be presented.
* An indication of what output is expected.

It also allows you to excersize an end point, presenting an entry form for required data.

Swagger is shown in this application in it's simplest form, there are many annotations that
can be added to the code to enhance what swagger displays.

## How api-demo works

The main method is in __uk.co.rpl.exampleapi.DemoApplication__, this is a standard SpringBoot startup
including the __@SpringBootApplication__ annotation.

### Controllers

There are two controllers

* __uk.co.rpl.exampleapi.controllers.HomeController__
* __uk.co.rpl.exampleapi.controllers.UserController__

and 1 exception handler

* __uk.co.rpl.exampleapi.controllers.ExceptionHandlers__

__HomeController__ only redirects __/__ to swagger documentation, so Swagger docs should also
be found at __http://localhost:8081/__.

__UserController__ provides information about Users, there are within it a fixed list of 4 users, 
the controller routes three end points:

* __/api/user/{id}__ Get user identified by index 0 to 3 i.e. __/api/user/3__.
* __/api/main-user__ Get the first user, this is equivalent to __/api/user/0__.
* __/api/users__ This returns a list of all 4 users

In all cases the returned data for a User is just  the two fields __firstName__ and __lastName__.

#### Exception Handler

__ExceptionHandler__ processes exceptions that are not caught before they leave the controllers.

It is marked with the annotation __@ControllerAdvice__ which indicates special controller configuration.

It only contains two handlers, these handle the NotFound exception in one way and all other exceptions differently.

__NotFound__ is thrown from the __UserService's__
__get(int id)__ method and hence from the __/api/user/{id}__ end point if __id__ is out of bounds. This will result in a __404 Not Found__ error being returned.

All other errors are trapped by the second exception handler, this causes a __500 Internal Server Error__ to be returned.

### Testing

Testing uses __Junit5__ sometimes called __Junit Jupiter__ as it is a completely rewritten version of __JUnit__
very similar to __Junit 4__ but with a slightly cleaner interface.

Test methods are annoted with __@Test__, a method annotated with __@BeforeEach__ will be run before test method.

There are 3 test classes:

* __DemoApplicationTests__ only tests that the application does not fail to start up, and was autogenerated by InteliJ.
* __UserControllerTest__ tests the user controller, this uses the spring class __MockMvc__ to mock the invocation of the 
__UserController__, so you can specify URIs and get a response asyou would from a real HTTP call.

In general the __perform__ method of __MockMvc__ take a uri, you can also specify headers and a body, though 
only the uri is used in these test cases.

The perform method returns a ResultActions class, you can use __andExpect__ to test various aspects of the result.

* __UserServiceTest__ tests the user service class, each __@Test__ method executes one of the methods in __UserService__
and then tests for correctness the returned data using __assertThat__, in general tests should be provided that
cause errors as well as perform normally to allow us to check that error behavious is reliable.

The __assertThat__ function is provided by the testing library __AssertJ__ it takes a single data item and provides 
a very rich set of tests against it.

The common one here is:
```
assertThat(object).extracting("xx", "yy").containsExactly("aa", "bb");
```
which means extract the fields __"xx"__ and __"yy"__ from object and check that 
__"xx"__ has the value __"aa"__ and __"yy"__ has the value __"bb"__.

This will work if the object has getters __getXx()__ and __getYy()__ or is a
Map containing entries __"xx"__ and __"yy"__.
